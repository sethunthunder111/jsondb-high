import { EventEmitter } from 'events';

/* auto-generated by NAPI-RS */

/** Query filter for parallel batch queries */
export interface QueryFilter {
  field: string
  op: string
  value: any
}
/** Batch query request */
export interface BatchQuery {
  path: string
  filters: Array<QueryFilter>
}
/** Parallel operation result */
export interface ParallelResult {
  success: boolean
  count: number
  error?: string
}
/** System resource info */
export interface SystemInfo {
  availableCores: number
  parallelEnabled: boolean
  recommendedBatchSize: number
}
export type NativeDB = NativeDb
export declare class NativeDb {
  constructor(path: string, wal: boolean)
  /** Get system resource information for adaptive parallelism */
  getSystemInfo(): SystemInfo
  load(): void
  save(): void
  /**
   * Execute batch set operations in parallel when beneficial
   * Automatically falls back to sequential for small batches
   */
  batchSetParallel(operations: Array<[string, any]>): ParallelResult
  /**
   * Parallel filter/query on a collection
   * Uses rayon for CPU-bound filtering when data is large enough
   */
  parallelQuery(path: string, filters: Array<QueryFilter>): any
  /** Parallel aggregation operations */
  parallelAggregate(path: string, operation: string, field?: string | undefined | null): any
  get(path: string): any
  set(path: string, value: any): void
  has(path: string): boolean
  delete(path: string): void
  push(path: string, value: any): void
}

/* TypeScript Wrapper Types */

export interface IndexConfig {
    name: string;
    path: string;
    field: string;
}
export interface MiddlewareContext<T = unknown> {
    path: string;
    value: T;
    operation: string;
    timestamp: number;
}
export type MiddlewareFn<T = unknown> = (ctx: MiddlewareContext<T>) => MiddlewareContext<T> | void;
export interface DBOptions {
    indices?: IndexConfig[];
    wal?: boolean;
    encryptionKey?: string;
    autoSaveInterval?: number;
}
export interface TTLEntry {
    path: string;
    expiresAt: number;
}
export interface PaginationMeta {
    total: number;
    pages: number;
    page: number;
    limit: number;
    hasNext: boolean;
    hasPrev: boolean;
}
export interface PaginationResult<T> {
    data: T[];
    meta: PaginationMeta;
}
export interface BatchOperation {
    type: 'set' | 'delete' | 'push' | 'add' | 'subtract';
    path: string;
    value?: unknown;
}
export type SortDirection = 1 | -1;
export interface SortOptions {
    [key: string]: SortDirection;
}
export interface ParallelConfig {
    /** Enable parallel processing (auto-detected by default) */
    enabled?: boolean;
    /** Minimum items before using parallel processing (default: 100) */
    threshold?: number;
    /** Maximum threads to use (default: auto-detected cores - 1) */
    maxThreads?: number;
}

export declare class WhereClause<T> {
    private queryBuilder;
    private field;
    constructor(queryBuilder: QueryBuilder<T>, field: string);
    eq(value: unknown): QueryBuilder<T>;
    ne(value: unknown): QueryBuilder<T>;
    gt(value: number): QueryBuilder<T>;
    gte(value: number): QueryBuilder<T>;
    lt(value: number): QueryBuilder<T>;
    lte(value: number): QueryBuilder<T>;
    between(min: number, max: number): QueryBuilder<T>;
    in(values: unknown[]): QueryBuilder<T>;
    notIn(values: unknown[]): QueryBuilder<T>;
    contains(substring: string): QueryBuilder<T>;
    startsWith(prefix: string): QueryBuilder<T>;
    endsWith(suffix: string): QueryBuilder<T>;
    matches(regex: RegExp): QueryBuilder<T>;
    exists(): QueryBuilder<T>;
    isNull(): QueryBuilder<T>;
    isNotNull(): QueryBuilder<T>;
}
export declare class QueryBuilder<T = unknown> {
    private items;
    private _limit?;
    private _skip?;
    private _sortOptions?;
    private _selectFields?;
    private filters;
    constructor(items: T[]);
    where(field: string): WhereClause<T>;
    filter(fn: (item: T) => boolean): QueryBuilder<T>;
    limit(n: number): QueryBuilder<T>;
    skip(n: number): QueryBuilder<T>;
    sort(options: SortOptions): QueryBuilder<T>;
    select(fields: string[]): QueryBuilder<T>;
    count(): number;
    sum(field: string): number;
    avg(field: string): number;
    min(field: string): number | undefined;
    max(field: string): number | undefined;
    distinct(field: string): unknown[];
    groupBy(field: string): Map<unknown, T[]>;
    exec(): Promise<T[]>;
    first(): T | undefined;
    last(): T | undefined;
}
export declare class JSONDatabase extends EventEmitter {
    private filePath;
    private native;
    private indices;
    private indexMaps;
    private beforeMiddlewares;
    private afterMiddlewares;
    private wal;
    private saveTimeout;
    private autoSaveInterval;
    private encryptionKey?;
    private ttlMap;
    private ttlEntries;
    private subscriptions;
    constructor(filePath: string, options?: DBOptions);
    /**
     * Force save to disk immediately
     */
    save(): Promise<void>;
    /**
     * Close the database gracefully
     */
    close(): Promise<void>;
    before<T = unknown>(method: string, pathPattern: string, fn: MiddlewareFn<T>): void;
    after<T = unknown>(method: string, pathPattern: string, fn: MiddlewareFn<T>): void;
    /**
     * Subscribe to changes on a path pattern
     * @param pathPattern - Path pattern with optional wildcards (* for single segment, ** for multiple)
     * @param callback - Function called when value changes
     * @returns Unsubscribe function
     */
    subscribe(pathPattern: string, callback: (value: unknown, oldValue: unknown) => void): () => void;
    /**
     * Set a key with TTL (expires after specified seconds)
     */
    setWithTTL(path: string, value: unknown, ttlSeconds: number): Promise<void>;
    /**
     * Set TTL on an existing key
     */
    setTTL(path: string, ttlSeconds: number): void;
    /**
     * Get remaining TTL for a key in seconds (returns -1 if no TTL, -2 if key doesn't exist)
     */
    getTTL(path: string): Promise<number>;
    /**
     * Remove TTL from a key (make it persistent)
     */
    clearTTL(path: string): void;
    /**
     * Check if a key has TTL set
     */
    hasTTL(path: string): boolean;
    set(path: string, value: unknown): Promise<void>;
    get<T = unknown>(path: string, defaultValue?: T): Promise<T>;
    has(path: string): Promise<boolean>;
    delete(path: string): Promise<void>;
    push(path: string, ...items: unknown[]): Promise<void>;
    pull(path: string, ...items: unknown[]): Promise<void>;
    add(path: string, amount: number): Promise<number>;
    subtract(path: string, amount: number): Promise<number>;
    findByIndex<T = unknown>(indexName: string, value: unknown): Promise<T | null>;
    /**
     * Manually trigger index rebuild
     */
    rebuildIndex(): void;
    query<T = unknown>(path: string): QueryBuilder<T>;
    find<T = unknown>(path: string, predicate: ((item: T) => boolean) | Record<string, unknown>): Promise<T | undefined>;
    findAll<T = unknown>(path: string, predicate: ((item: T) => boolean) | Record<string, unknown>): Promise<T[]>;
    paginate<T = unknown>(path: string, page: number, limit: number): Promise<PaginationResult<T>>;
    batch(ops: BatchOperation[]): Promise<void>;
    transaction<T = unknown>(fn: (data: T) => Promise<T> | T): Promise<T>;
    createSnapshot(name: string): Promise<string>;
    restoreSnapshot(snapshotPath: string): Promise<void>;
    /**
     * Get all keys under a path
     */
    keys(path?: string): Promise<string[]>;
    /**
     * Get all values under a path
     */
    values<T = unknown>(path?: string): Promise<T[]>;
    /**
     * Get count of items under a path
     */
    count(path?: string): Promise<number>;
    /**
     * Clear all data
     */
    clear(): Promise<void>;
    /**
     * Get database statistics
     */
    stats(): Promise<{
        size: number;
        keys: number;
        indices: number;
        ttlKeys: number;
        subscriptions: number;
    }>;
    /**
     * Get system resource information for parallel processing decisions
     * Returns info about available cores and whether parallel mode is enabled
     */
    getSystemInfo(): SystemInfo;
    /**
     * Execute batch set operations with automatic parallel optimization.
     * Uses multiple CPU cores when workload is large enough (≥100 items).
     * Falls back to sequential processing for small batches to avoid overhead.
     *
     * @param operations - Array of {path, value} objects to set
     * @returns ParallelResult with success status and count of operations completed
     *
     * @example
     * ```typescript
     * const result = await db.batchSetParallel([
     *     { path: 'users.1', value: { name: 'Alice' } },
     *     { path: 'users.2', value: { name: 'Bob' } },
     *     // ... potentially thousands more
     * ]);
     * console.log(`Completed ${result.count} operations`);
     * ```
     */
    batchSetParallel(operations: Array<{
        path: string;
        value: unknown;
    }>): Promise<ParallelResult>;
    /**
     * Execute parallel query with native Rust filtering.
     * More efficient than JS-based queries for large datasets (≥100 items).
     * Automatically uses parallel iteration when beneficial.
     *
     * @param path - Path to the collection to query
     * @param filters - Array of filter conditions to apply
     * @returns Filtered results array
     *
     * @example
     * ```typescript
     * const adults = await db.parallelQuery('users', [
     *     { field: 'age', op: 'gte', value: 18 },
     *     { field: 'status', op: 'eq', value: 'active' }
     * ]);
     * ```
     */
    parallelQuery<T = unknown>(path: string, filters: QueryFilter[]): Promise<T[]>;
    /**
     * Parallel aggregation operations using native Rust processing.
     * Efficiently computes sum, avg, min, max, or count over large datasets.
     *
     * @param path - Path to the collection
     * @param operation - Aggregation type: 'sum', 'avg', 'min', 'max', or 'count'
     * @param field - Optional field to aggregate (required for sum, avg, min, max)
     * @returns Aggregation result or null if no data
     *
     * @example
     * ```typescript
     * const totalSales = await db.parallelAggregate('orders', 'sum', 'amount');
     * const avgAge = await db.parallelAggregate('users', 'avg', 'age');
     * const userCount = await db.parallelAggregate('users', 'count');
     * ```
     */
    parallelAggregate(path: string, operation: 'sum' | 'avg' | 'min' | 'max' | 'count', field?: string): Promise<number | null>;
}
export default JSONDatabase;
